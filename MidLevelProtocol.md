# Описание протокола взаимодействия между 2-ым уровнем (ECU) и 3-им уровнем (APP)

## Модель данных передаваемых между 2ым и 3им уровнем

Перед тем как описывать протокол, для начала стоит понять какого рода данные точно будут передаваться, а так же какие мы
можем захотеть передавать в будущем.

Итак, какие данные мы будем передавать:

1. Запрос 1/2/4/8 байтных значений (скорость, заряд итд. Таких значений в будущем могут быть **сотни**)
2. Ответ на запрос с 1/2/4/8 байтными значением
3. Запрос сразу нескольких 1/2/4/8 байтных значений (для увеличения частоты обновления, уменьшения % служебный данных)
4. Ответ на запрос сразу нескольких 1/2/4/8 байтных значений
5. Запрос на установку 1/2/4/8 байтного значения (включение стоп-сигналов, света итд)
6. Подтверждение установки 1/2/4/8 байтного значения
7. Чтение и запись больших объемов данных (конфигурации ECU, контроллеров мотор колес итд)
8. Запись прошивки как самого ECU так и обновляемых контроллеров на шине CAN
9. Трансляция debug логов с ECU на третий уровень

Я не говорю, что мы обязательно поддержим все пункты из списка, но хотелось бы заложить потенциальную возможность
передачи любых из этих данных.

## Ограничения накладываемые микроконтроллером.

Да современные микроконтроллеры обладают хорошим быстродействием и значительным объемом памяти, однако хотелось бы по
возможности уменьшить накладные расходы связанные с обработкой пакетов

Что хотелось бы учесть в протоколе:

1. Избежать аллокации буферов динамического размера введя максимальный размер одного пакета
2. Избежать большого объема передаваемой информации путем введения динамического размера пакетов (не больше
   максимального)
3. По возможность минимизировать копирование участков памяти (zero copy), как решение тут не копировать payload если он
   полностью помещается в один пакет
4. Сохранить возможность передачи объема информации превышающий максимальный размер полезной нагрузки, путем возможности
   разбиения большого пакета на маленькие

## Почему нам не подходят готовые протоколы

А вот тут не знаю, я не нашел ничего, что удовлетворяло бы всем пунктам выше.

# Предлагаемая реализация протокола

Возможная структура псевдокодом (нет это не с/с++) (ниже будет описание каждого поля):

```
struct packet {
   uint16 functionId; // или 8 байт хватит? (нюансы ниже)
   uint8 packetId;
   uint8 payloadSize;
   uint8[payloadSize] payload;
   uint16 crc16;
}
```

1. Максимальный размер пакета задаем как N (известное на момент компиляции число, которое впрочем сможем поменять если
   захотим, естественно до выхода в прод, потом уже поздно будет). Это позволит заранее знать размер буфера в который
   точно влезет пакет. Начать предлагаю с 32 байт.
2. Максимальный размер полезной нагрузки соответственно N - размер служебных данных.
3. Такая структура пакета позволит использовать прямое отображение структуры на память (с нюансами в виде вычисления
   сдвига crc) или мы вообще можем не выделать память под всю структуру, а хранить functionId в отдельной переменной, а
   payloadSize и crc16 забыть сразу после выполнения их предназначения.
4. packetId нужен для возможности понять на какой запрос пришел ответ если было отправлено несколько запросов
   одновременно (что является нормальной практикой).
5. При запросе packetId инкриминируется (подразумевается что мы не можем отправить 128 запросов подряд и за все это
   время не получить ответа на самый первый. Почему 128 а не 256 описано ниже)
6. Что бы избежать коллизии (например запрос с id=1 со стороны ECU может быть воспринят как ответ на ранее отправленный
   запрос от APP с тем же id=1). Мы разделаем возможный пул id. App использует id от 0 до 127 а ECU от 128 до 255.
7. Тут есть нюанс, что микроконтроллеру нужно будет где-то хранить некий пул неотвеченных пакетов (что бы понять на
   какой запрос пришел ответ), это может быть сложным для контроллера. Тут есть несколько решений. Или хранить
   полноценную таблицу (не так уж и часто контролеру нужно будет первому обращаться) или игнорировать packetId если нам
   достаточно functionId для обработки ответа. Предлагаю это сделать булевым флагом при отправке запроса.
8. functionId нужен для дальнейшей передачи пакета функции обработчику. Функция обработчик должна иметь одну и ту же
   сигнатуру `void function f(uint8 functionId, uint8* payload, uint8 payloadSize, uint8 packetId)`, это позволит
   создать массив с
   указателями на функции
   обработчики где functionId будет являться индексом в массиве. Это так же позволит добавлять новые обработчики не
   меняя протокол.
9. За отправку ответа ответственна сама функция `f`. При этом в ответе должен быть тот же packetId что и в запросе.
10. На корректный запрос **всегда** должен следовать ответ после его исполнения
11. Для достижения zero copy вводим ограничение, что массив может быть переиспользован после выхода из функции `f`.
    Соответственно если функции нужно будет куда-то сохранить данные, то тут уже нужно будет копировать.
12. Для передачи данных объемом больше чем размер payload будет использоваться специальная функция для склейки пакетов (
    о ней подробнее ниже)
13. Строго говоря в ответе не нужен functionId так как что бы понять как обрабатывать пакет достаточно packetId, но тем
    неимение это поле может быть полезно со стороны MC для снижения расходов на поддержание таблицы сопоставления
    packetId. Поэтому договаривается, что functionId в ответе должен быть тот же, что и в заголовке. (Да я специально не
    разделил пакеты на пакеты запроса/ответа и оставил это частично бесполезное поле. Специально для возможности не
    записывать packetId в таблицу сопоставления со стороны ECU если ему по факту плевать) Честно говоря, это довольно
    скользкий момент, возможно тут стоит все же разделить формат запроса и ответа?

Нюанс: я не предлагаю делать отдельный обработчик на каждый простой параметр по типу скорость/заряд/итд. С обработкой
всех этих параметров вполне справится один обработчик. Если делать именно один обработчик на пачку значений, то нам
хватит 256 возможных обработчиков и можно будет юзать 1 байт на functionID

Нюанс: тут может показаться, что инициировать запрос можно только с третьего уровня, но это не так. Никто не мешает
инициировать запрос со стороны ECU, если App имеет соответствующий обработчик

### Функция для склейки пакетов

TODO - кратко тут будет стандарт payload который передается в функцию, она склеивает их в один массив, а потом передает
в другую функцию обработчик id которой берет из payload

### Обработка ошибок и защита от рассинхронизации буферов о которой я спрашивал на собрании

1. В случае если на шине нет новых данных в течении N ms, сбрасываем текущий буфер
2. В случае невалидной crc отправляем запрос со специальным functionID (обработчик ошибки). Вторая сторона после
   получения запроса на обработчик ошибки должна прекратить передачу не менее чем на N ms (это позволит гарантировать
   сброс буфера)